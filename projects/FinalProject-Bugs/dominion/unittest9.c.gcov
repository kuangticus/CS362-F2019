        -:    0:Source:unittest9.c
        -:    0:Graph:unittest9.gcno
        -:    0:Data:unittest9.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include <string.h>
        -:    4:#include <stdio.h>
        -:    5:#include <assert.h>
        -:    6:#include "rngs.h"
        -:    7:
function main called 1 returned 100% blocks executed 88%
        1:    8:int main() {
        -:    9:    int i;
        1:   10:    int seed = 1000;
        1:   11:    int numPlayer = 2;
        1:   12:    int maxHandCount = 5, cp = 0; // cp is current player
        -:   13:
        1:   14:    int k[10] = {adventurer, council_room, feast, ambassador, mine
        -:   15:                , remodel, baron, village, tribute, great_hall};
        -:   16:    struct gameState G;
        -:   17:    
        -:   18:    // for current player
        1:   19:    int testHand[maxHandCount];
        1:   20:    testHand[0] = tribute; 
        1:   21:    testHand[1] = copper;
        1:   22:    testHand[2] = baron;
        1:   23:    testHand[3] = estate;
        1:   24:    testHand[4] = estate;
        -:   25:
        1:   26:    memset(&G, 23, sizeof(struct gameState));   // clear the game state
        1:   27:    initializeGame(numPlayer, k, seed, &G); // initialize a new game
call    0 returned 100%
        1:   28:    G.deckCount[cp] = maxHandCount;                 // set the number of cards on hand
        1:   29:    memcpy(G.hand[cp], testHand, sizeof(int) * maxHandCount); 
        -:   30:
        -:   31:    // for ease of testing I have made all the cards to be treasure cards
       11:   32:    for ( i =0 ; i < G.deckCount[cp+1]; i++){
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       10:   33:        G.deck[cp+1][i] = copper; 
        -:   34:    }
        -:   35:
        -:   36:    // has the next player draw 5 cards
        1:   37:    printf("Testing drawCard() this needs to work in order for the logic to work.\n");
call    0 returned 100%
        6:   38:    for ( i = 0; i < maxHandCount; i++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        5:   39:        drawCard(cp+1, &G);
call    0 returned 100%
        -:   40:    }
        1:   41:    if ( G.handCount[cp+1] != 5)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   42:        printf("Broken drawCard Logic.\n");
call    0 never executed
        1:   43:    assert( G.handCount[cp+1] == 5);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   44:
        1:   45:    printf("End of Testing drawCard().\n");
call    0 returned 100%
        -:   46:
        1:   47:    printf("Testing cardEffect() tribute case statement.\n");
call    0 returned 100%
        -:   48:    int bonus;
        1:   49:    int initAction = G.numActions;
        -:   50:
        1:   51:    cardEffect(G.hand[cp][0], 0, 0, 0, &G, 0, &bonus);
call    0 returned 100%
        -:   52:
        1:   53:    if (initAction != G.numActions )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   54:        printf("Something is not right with bonus logic handling! \n");
call    0 returned 100%
        -:   55:    
        1:   56:    if (initAction == G.numActions)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   57:        printf("Code correcly handles a -1 index in the tributeRevealedCards.\n");
call    0 never executed
        -:   58:    else
        1:   59:        printf("Code incorrecly handles a -1 index in the tributeRevealedCards.\n");
call    0 returned 100%
        -:   60:
        1:   61:    printf("End of testing for bug 9 cardEffect() tribute case statement. \n");
call    0 returned 100%
        -:   62:
        1:   63:    return 0;
        -:   64:}
